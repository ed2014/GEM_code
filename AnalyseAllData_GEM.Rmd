---
title: "AnalyseGEM"
author: "edmar.teixeira@me.com"
date: "Sunday, December 07, 2014"
output: html_document
---

# Background

## Aim

Quantify **uncertanty** (sensitivity of model to?) coming from the choice of (possible?) **sowing dates and maize hybrids** in regional simulations

## Method

> Use APSIM 7.4

> Run model for ~2700 pixels of 5 x 5 km (NIWA ref XXX) across New Zealand

> Arable land filter frpm LandCare (ref XXX)

> Run 30 years (XXX-XXXX) of data from NIWA (XXXX)

> Run 5 hybrid maturity types (parameter XXXX with values x, x, x, x, x)

> Run at 5 different sowng dates (1-Sep, 1-Oct, 1-Nov, 1-Dec, 1-Jan)


# Data Manipulation

```{r LoadLibs, echo=TRUE, include=FALSE}
gc()
library(ggplot2)
library(plot3D)
library(gridExtra)
library(tidyr)
library(raster)
library(mapproj)
library(dplyr)
```

## Retrieve data and check
```{r GetData, include=FALSE}
# load data from HD
#setwd("E:\\SowByGenotype")
setwd("C:\\Apsim_dev\\Projects\\2014-SowByGenotype\\GEM_data")
#setwd("C:\\Apsim_dev\\Projects\\2014-SowByGenotype\\outFiles")

load("DATA_GEM.Rda", .GlobalEnv)


head(DATA_GEM)
tail(DATA_GEM)
summary(DATA_GEM)

print(paste0("Found ", length(unique(DATA_GEM$row)), " rows"))
print(paste0("Found ", length(unique(DATA_GEM$col)), " cols"))
print(paste0("Found ", length(unique(DATA_GEM$row * DATA_GEM$col)), " pixels"))

```

> Subset to keep only maize (exclude winter forage wheat) and order factors

```{r TidyUp, echo = FALSE, include=FALSE}
# Remove wheat (catch crop rotation) and keep only maize data
workDF <- NULL
workDF <- subset(DATA_GEM, CurrentCrop != 'wheat_exceed')

# order sow dates
workDF$thisSow <- factor(workDF$thisSow, levels = c('s1', 's2', 's3', 's4', 's5'))
workDF$thisHyb <- factor(workDF$thisHyb, levels = c('h1', 'h2', 'h3', 'h4', 'h5'))
#workDF$thisSow <- factor(workDF$thisSow, levels = c('s1', 's2', 's3', 's4'))
#workDF$thisHyb <- factor(workDF$thisHyb, levels = c('h1', 'h2', 'h3', 'h4'))


#creates ID for each pixel
workDF$pixel_ID <- paste0(workDF$row,"_",workDF$col)

# Creates a year field as factor
workDF$yearAsFact <- as.factor(paste0(workDF$year,"_Y"))

# Average TT accumulation per day of regrowth (proxy for average Temp during cycle) 
workDF <- workDF %>%  mutate(TTav = TTsum/GrowthLength)

summary(workDF)

# Read region data
df_region <- as.data.frame(read.csv(file = 
                                        paste0("C:\\Apsim_dev\\Projects\\2014-SowByGenotype\\GEM_data\\",
                                   "RegionPerPixel.csv") ))

df_region <- df_region %>% select (-X)
head(df_region)

#workDF <- merge(workDF, df_region, by = c("row", "col")) # FIXME: this is deleting some pixels
# FIXME: region merge is deleting Canterbury latitude
 
head(workDF)

# Read climate zone data
climZones <- read.csv("C:\\Apsim_dev\\Projects\\2014-SowByGenotype\\GEM_data\\CLuster.csv")
head(climZones)
climZones$rowNew <- climZones$row - 1 # climZones[,rowNew] - 1
climZones$colNew <- climZones$col - 1 # climZones[,colNew] - 1
workDF <- merge(workDF, climZones, by = c("row", "col")) # FIXME: this is deleting some pixels
workDF$Combine <- factor(workDF$Combine, levels = c('LTLR', 'LTMR', 'LTHR', 
                                                    'MTLR','MTMR', 'MTHR', 
                                                    'HTLR', 'HTMR', 'HTHR'))

#write.table(climZones, file="climZones.txt"), row.names=FALSE, col.names=TRUE, sep=" ",
#               append=FALSE, quote=FALSE)

# Give numeric labels to factor levels
workDF$thisSow_n[workDF$thisSow == "s1"] <- 1
workDF$thisSow_n[workDF$thisSow == "s2"] <- 2
workDF$thisSow_n[workDF$thisSow == "s3"] <- 3
workDF$thisSow_n[workDF$thisSow == "s4"] <- 4
workDF$thisSow_n[workDF$thisSow == "s5"] <- 5

workDF$thisHyb_n[workDF$thisHyb == "h1"] <- 1
workDF$thisHyb_n[workDF$thisHyb == "h2"] <- 2
workDF$thisHyb_n[workDF$thisHyb == "h3"] <- 3
workDF$thisHyb_n[workDF$thisHyb == "h4"] <- 4
workDF$thisHyb_n[workDF$thisHyb == "h5"] <- 5

summary(workDF)
head(workDF)
print(paste0("Found ", length(unique(workDF$pixel_ID)), " pixels"))
save(workDF,file="workDF_GEM.Rda")

```

Get pooled values per climatic zones

```{r TableResClimZone}

workDF %>%
  group_by(Combine) %>%
  select(TotalBiomass, HarvestIndex) %>%
  mutate(TotalBiomass_Mg = TotalBiomass/1000) %>%
  summarise_each(funs(mean, sd)) %>%
  mutate(Bio_CV = ((TotalBiomass_Mg_sd/TotalBiomass_Mg_mean)*100), 
                   HI_CV = ((HarvestIndex_sd/HarvestIndex_mean)*100))  %>%
  select(Combine,TotalBiomass_Mg_mean, Bio_CV, HarvestIndex_mean,HI_CV)

workDF %>%
  select(TotalBiomass, HarvestIndex) %>%
  summarise_each(funs(mean))

# Area in Kha 
workDF %>%
  group_by(Combine) %>%
  select(pixel_ID) %>%
  summarise(Unique_Pixels = n_distinct(pixel_ID)) %>%
  mutate(apr_area_kha = Unique_Pixels * 2500/1000)


```

Select some pixels across the range of results for 3D graph

```{r 3DGraphsByPixel, echo = FALSE}

df_sel <- workDF %>%
  group_by(Combine, row,col, pixel_ID, thisSow_n, thisHyb_n) %>%
  summarise(bio = mean(TotalBiomass), hi = mean(HarvestIndex))  %>%
  filter(pixel_ID == "24_157" | pixel_ID == "189_106" | pixel_ID == "240_45") %>%
    write.table(file=paste0("3D_graph.txt"), 
                row.names=FALSE, col.names=TRUE, sep=" ", append=FALSE, quote=FALSE)
 # count(Combine,bio,hi) %>%
 # filter(bio == max(bio)) %>%
 # filter(Combine == "LTLR" | Combine == "MTMR"| Combine == "HTHR" ) %>%

pixels <- unique(df_sel$pixel_ID)

for (p in 1:length(pixels)) {
  df_sel %>%
  filter(pixel_ID == pixels[p])  %>%
  write.table(file=paste0(pixels[p],"_3D_graph.txt"), row.names=FALSE, col.names=TRUE, sep=" ", append=FALSE, quote=FALSE)
  print(pixels[p])
  
  # graph it FIXME: do it later
par(mfrow = c(1, 2))

# Plot 3 D graph
z <- matrix(df_pix[["bio"]],                       # the data elements 
nrow=length(unique(df_pix$thisHyb_n)),              # number of rows 
ncol=length(unique(df_pix$thisSow_n)),              # number of columns 
byrow = TRUE)                                     # fill matrix by rows 
colnames(z) = unique(df_pix$thisHyb_n)
rownames(z) = unique(df_pix$thisSow_n)

x = as.numeric(colnames(z))
y = as.numeric(rownames(z))
  
persp3D(x, y, z, theta=60, phi=10, expand=0.75,
        main= paste0("Bio_mean: ",pixels[p]),
        ticktype="detailed", lighting = TRUE, 
        xlab="Sow date", ylab="Hybrid", zlab="Biomass (t/ha)",axes=TRUE)


# variaility
# PLot 3 D graph
z = matrix(df_pix[["hi"]], # the data elements 
nrow=length(unique(df_pix$thisHyb_n)),              # number of rows 
ncol=length(unique(df_pix$thisSow_n)),              # number of columns 
byrow = TRUE)        # fill matrix by rows 
colnames(z) = unique(df_pix$thisHyb_n)
rownames(z) = unique(df_pix$thisSow_n)

x = as.numeric(colnames(z))
y = as.numeric(rownames(z))
  
persp3D(x, y, z, theta=60, phi=10, expand=0.75, 
        main= paste0("HI: ",pixels[p]),
        ticktype="detailed", lighting = TRUE, xlab="Sow date", 
        ylab="Hybrid", zlab="Biomass (t/ha)",axes=TRUE)

  
  }


```

## Calculate the relative variability for factors

> How much of overall variation is coming from sowing date, hybrid and their interaction?

> Adapting Esther Meenken method of sensitivity analysis for that

> Run a ANOVA and retrive the Sums of Squares (SS) of each factor (3 main factors and the interaction)

> Display it as a relative proportion of total variation (% of total SS)

> This is the **Si index** summary:

```{r ANOVA, echo =FALSE}
# do an anova for each pixel 
# This loop takes ages!

si_df_final <- NULL
pixels <- unique(workDF$pixel_ID)

summary(workDF) # Should I use workDF?
head(workDF)


 #for (p in 1:10) { # for script test
 for (p in 1:length(pixels)) {

  
  # thisPixDF <- filter(workDF_med, pixel_ID == pixels[[p]])
 # thisPixDF <- filter(workDF, pixel_ID == pixels[[p]])
  thisPixDF <- filter(workDF, pixel_ID == pixels[[p]])
  
 # Remove slected sowing dates and hybrids from the analysis (not working)
 # thisPixDF <- subset(thisPixDF, thisHyb != "h2" | 
                     #   thisHyb != "h4" |
                     #   thisSow != "s1" |
                     #   thisSow != "s5" )
  
  head(thisPixDF)
  summary(thisPixDF)
         
  # do anova
  anova <- aov(TotalBiomass ~ thisHyb*thisSow*yearAsFact, data = thisPixDF)

  anovaTable <- summary(anova)
  
  #Retrive SS and MS values
  anova_SS <- anovaTable[[1]]$'Sum Sq'
  anova_MS <- anovaTable[[1]]$'Mean Sq' 

  # Binds all SS for each variable together into a new df
  df_ss <- data.frame(SS = anova_SS, MS = anova_MS)

  #retrieves row names and load into result df
  namesAnTab <- rownames(anovaTable[[1]])
  rownames (df_ss) <- gsub(" ","",namesAnTab) # remove spaces
 
 # get names and count of main factors
 mainFact <- rownames (df_ss)[-grep(':',rownames (df_ss))] # isolate the main factors from

  # Creates a column with "normalised" percent of total variation (SS) 
  # in relation to total SS for each factor in that pixel
  df_ss$SS_p <- round((df_ss$SS/sum(df_ss$SS))*100,3)
  df_ss$MS_p <- round((df_ss$MS/sum(df_ss$MS))*100,3) 
  # FIXME: Not sure which to use SS or MS - Esther Menkeen suggested SS
  df_si <- NULL
  df_si <- data.frame(thisLat = thisPixDF$thisLat[1],
                   thisLong = thisPixDF$thisLong[1],
                   thisRegion = thisPixDF$region[1],
                   row = thisPixDF$row[1],
                   col = thisPixDF$col[1],
                   df_ss$SS_p[1], 
                   df_ss$SS_p[2], 
                   df_ss$SS_p[3],
                   df_ss$SS_p[4]
                   )
  
 # isolate factor labels from data
 factNames <- colnames (df_si)[-grep('ss',colnames (df_si))] # isolate the main factors from anova
 noFactors <- length(factNames)  # counts row names that do not have ":" i.e. from interaction
 
  # label Si df FIXME: Automate this
  colnames(df_si)[noFactors+1] <- gsub(" ","",paste0("Si_",mainFact[1]))
  colnames(df_si)[noFactors+2] <- gsub(" ","",paste0("Si_",mainFact[2]))
  colnames(df_si)[noFactors+3] <- gsub(" ","",paste0("Si_",mainFact[3]))
  colnames(df_si)[noFactors+4] <- "Si_Interac"
  
  # Appends to final Si df
  if(p==1){ 
    si_df_final <- data.frame(df_si)  
    } else {
    si_df_final <- rbind(si_df_final, df_si)
    }
 print(paste0("In pixel ",p))
}

head(si_df_final)
nrow(si_df_final)

# Graph Si for eacj main factor and interaction
#gH <- ggplot(si_df_final, aes(x=Si_thisHyb)) + geom_histogram(binwidth=.5, colour="black", fill="white")
#gS <- ggplot(si_df_final, aes(x=Si_thisSow)) + geom_histogram(binwidth=.5, colour="black", fill="white")
#gW <- ggplot(si_df_final, aes(x=Si_yearAsFact)) + geom_histogram(binwidth=.5, colour="black", fill="white")
#gI <- ggplot(si_df_final, aes(x=Si_Interac)) + geom_histogram(binwidth=.5, colour="black", fill="white")

# Give same names to the regions in df
df_reg_names <- read.csv("C:\\Apsim_dev\\Projects\\2014-SowByGenotype\\GEM_data\\RegionPerPixel.csv")
#FIXME: Add region names from csv file or env names
#df_reg_names <- data.frame(thisRegion = c(1,2,3,4,5,6,7,8,9,12,13,14,15,16,17,18, 99),  
              #             regNames = c("Northland", "Auckland", "Waikato", 
               #                        "BOP", "Gisborne", "HawkesBay", "Taranaki",
                #                       "Manuatu", "Wellington", "WestCoast", 
                 #                      "Canterbury", "Otago", "Southland", 
                  #                     "Tasman", "Nelson", "Malborough", 
                   #                    "Others"))
#si_df_final_m <- merge(si_df_final,df_reg_names, by = c("thisRegion"))

head(si_df_final_m)
# save this DF 
write.table(si_df_final_m, file="Si_by_Pixel.txt"), row.names=FALSE, col.names=TRUE, sep=" ",
               append=FALSE, quote=FALSE)

# All plotted together by region
fontSize <- 25
si_df_final_m %>%
  subset(thisRegion == 3 | thisRegion == 6 | thisRegion == 13 | thisRegion == 14) %>%
  group_by(thisLat, thisLong) %>%
  gather(factName, siVal, 4:7) %>% # FIXME: this might change - can you automate?
  ggplot(aes(x= siVal, colour=factName, fill=factName)) + 
  geom_histogram(aes(y=..density..), binwidth=.8, alpha=0) +
 # geom_histogram(binwidth=1, alpha=0) +
  geom_density(alpha=0.2,size=1.5) +
 # facet_grid(thisRegion~. , scales="free") +
  facet_wrap(~regNames, scales="free") +
  xlab("Percent of total variability (%)") +
  ylab("Frequency distribution") +
  theme(text = element_text(size=fontSize)) + 
  theme(legend.position = c(0, 1), 
       legend.justification = c(-3.5, 1)) 
 # scale_fill_discrete(name="Factors", labels=c("Hybrids","Sowing date","Weather", "Interactions")) +

# Plot distributions of Si
#grid.arrange(gH, gS, gW,gI, nrow=4)
#si_df_final_m_bkp <- si_df_final_m
```


> Histograms show frequency of pixels in each range of Si for each factor and interactions


```{r SiAnalysis}

weatherPixel <- read.csv("F:\\ERA-40_Reanalysis\\MetFiles_1971_2000\\SummaryResults\\RasterOutput_base.csv")
weatherPixel <- data.frame(weatherPixel)
head(weatherPixel)
summary(weatherPixel)
si_weather_merged <- NULL
si_weather_merged <- merge(si_df_final, weatherPixel, by = c("thisLat","thisLong")) # FIXME: do row/col as its safer

si_weather_merged <- si_weather_merged %>%
  mutate(meant = (maxt+mint)*0.5)
  

head(si_weather_merged)
# "year  day  maxt	mint	radn	rain	co2"

si_weather_merged %>%
  ggplot(aes(x=meant, y=Si_thisHyb)) +
  geom_point() +
  geom_smooth(method=lm) +
  theme(text = element_text(size=20)) +
  xlab("Average temperature (oC)") +
  ylab("Sensitivity to hybrid\n(% of total variability)")

si_weather_merged %>%
  ggplot(aes(x=meant, y=Si_thisSow)) +
  geom_point() +
  geom_smooth()  +
  theme(text = element_text(size=20)) +
  xlab("Average temperature (oC)") +
  ylab("Sensitivity to sowing date\n(% of total variability)")


si_weather_merged %>%
  ggplot(aes(x=meant, y=Si_yearAsFact)) +
  geom_point() +
  geom_smooth()  +
   theme(text = element_text(size=20)) +
  xlab("Average temperature (oC)") +
  ylab("Sensitivity to weather\n(% of total variability)")


si_weather_merged %>%
  ggplot(aes(x=meant, y=Si_Interac)) +
  geom_point() +
  geom_smooth()  +
  theme(text = element_text(size=20)) +
  xlab("Average temperature (oC)") +
  ylab("Sensitivity to interactions\n(% of total variability)")



# radiation
si_weather_merged %>%
  ggplot(aes(x=radn, y=Si_thisHyb)) +
  geom_point() +
  geom_smooth() 

si_weather_merged %>%
  ggplot(aes(x=radn, y=Si_thisSow)) +
  geom_point() +
  geom_smooth() 

si_weather_merged %>%
  ggplot(aes(x=radn, y=Si_yearAsFact)) +
  geom_point() +
  geom_smooth() 

si_weather_merged %>%
  ggplot(aes(x=radn, y=Si_Interac)) +
  geom_point() +
  geom_smooth() 

```




## Map Si index

> Si is the fraction of total sums of squares attributed to each main factor or interactions

> Let's plot it: 

```{r MapSi, echo = FALSE, warning=FALSE}
outNames <- colnames(si_df_final)
outNames <- gsub(" ","",outNames )
#par(mfrow=c(1,(length(mainFact)+1)))
par(mfrow=c(2,2))

# ignore first 6 factors
spg <- list() # dataframe list to be coerced as spatial object
rast <- list() # raster
s <- list()


# FIXME: This is by hand now
factNames <- c("Region", "Latitude","Longitude", "Si Hybrid","Si Sow date", "Si Weather", "Si Interactions", "Regions")

# TODO: add a region code and then plot it for each region in the loop
for(o in length(mainFact):length(outNames)){

  # For aggregate
  spg[[o]] = data.frame(si_df_final$thisLong, si_df_final$thisLat, si_df_final[[o]])
  coordinates(spg[[o]]) = ~ si_df_final.thisLong + si_df_final.thisLat # Attention to variable names
 
  # Common to both methods (grid, raterise and project)
  gridded(spg[[o]]) <- TRUE
  rast[[o]] <- raster(spg[[o]])
  proj4string(rast[[o]]) <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"

  # stack them
  if(o == 1) {
    s <- NULL
    s <- stack(rast[[o]])} 
  else {
    s[[o]] <- rast[[o]]
  }
  
  
  # plot them
  if (o %in% 4:7) {
    plot(rast[[o]], main = paste0(factNames[o]))
    
    # save raster as
    writeRaster(rast[[o]], file=paste0("Si_", outNames[o],".tiff"), overwrite=TRUE) 

  }
   
  # map('nz')
}
#map(database= "usa", col="#FFFFFF", fill=FALSE,add=TRUE, lwd=1.5)

```



## Graph some results

> Total silage biomass by sowing date (kg/ha)

```{r GraphBySow, echo=FALSE}

# Pooled pixels response to sow date by hybrid

# Total biomass
workDF %>%
#subset(region == 4 |region == 11 | region == 13) %>%
ggplot(aes(x= thisSow , y=TotalBiomass)) +  
geom_boxplot() +
#facet_grid(region ~ thisHyb)
facet_grid(. ~ thisHyb)

# Total Yield
workDF %>%
#subset(region == 4 |region == 11 | region == 13) %>%
ggplot(aes(x= thisSow , y=TotalYield)) +  
geom_boxplot() +
#facet_grid(region ~ thisHyb)
facet_grid(row~ thisHyb)

# Harvest Index
workDF %>%
ggplot(aes(x= thisSow , y=HarvestIndex)) +  
geom_boxplot() +
facet_grid( .~ thisHyb)

# Water Use
workDF %>%
ggplot(aes(x= thisSow , y=ETact)) +  
geom_boxplot() +
facet_grid( .~ thisHyb)

# Water Use Efficiency
workDF %>%
ggplot(aes(x= thisSow , y=WUE)) +  
geom_boxplot() +
facet_grid( .~ thisHyb)

# Radiation use Efficiency
workDF %>%
ggplot(aes(x= thisSow , y=RUEtop)) +  
geom_boxplot() +
facet_grid( row~ thisHyb)


# Light Interception
workDF %>%
ggplot(aes(x= thisSow , y=IntRadSum)) +  
geom_boxplot() +
facet_grid( row~ thisHyb)


```

> Total silage biomass by hybrid type (kg/ha)

This form of display seems more interesting.

- Advantege of long hybrids is reduced at late sowing dates

```{r GraphByHyb, echo = FALSE}

# Pooled response to Hybrid (Bio)
# Total biomass
workDF %>%
#subset(region == 4 |region == 11 | region == 13) %>%
#subset(thisSow == "s5") %>%
ggplot(aes(x= thisHyb , y=TotalBiomass)) +  
geom_boxplot() +
#facet_grid( region~ thisSow)
facet_grid(. ~ thisSow)# +
#facet_wrap(~Combine, ncol = 3)

# Total Yield
workDF %>%
ggplot(aes(x= thisHyb , y=TotalYield)) +  
geom_boxplot() +
facet_grid( row~ thisSow)

# Harvest Index
workDF %>%
ggplot(aes(x= thisHyb , y=HarvestIndex)) +  
geom_boxplot() +
facet_grid( row~ thisSow)

# Water Use
workDF %>%
ggplot(aes(x= thisHyb , y=ETact)) +  
geom_boxplot() +
facet_grid( .~ thisSow)

# Water Use Efficiency
workDF %>%
ggplot(aes(x= thisHyb , y=WUE)) +  
geom_boxplot() +
facet_grid( .~ thisSow)

# Water Use Efficiency
workDF %>%
ggplot(aes(x= thisHyb , y=WUE)) +  
geom_boxplot() +
facet_grid( .~ thisSow)

```

# Analysis

## Calculate variability as CV%

> Just to have an initial idea of variability

> Considers variation among YEARS and PIXELS together

> Pooled among hybrids and sowing dates


```{r GraphCVs, echo =FALSE}
# polled CV across hybrids and sowing dates

workDF %>%
  group_by(thisLat,thisLong,thisSow, thisHyb) %>%
  summarise_each(funs(sd, mean)) %>%
  select(thisSow, thisHyb,thisLat,thisLong,TotalBiomass_sd, TotalBiomass_mean) %>%
  mutate(CV= (TotalBiomass_sd/TotalBiomass_mean) *100) %>%
  ggplot(aes(x= thisLat , y=TotalBiomass_mean)) + 
  geom_point() +
  facet_grid(.~ thisHyb)

workDF %>%
  group_by(row, col, thisLat, thisLong) %>%
  summarise_each(funs(sd, mean)) %>%
  select(thisLat,thisLong,TotalBiomass_sd, TotalBiomass_mean) %>%
  mutate(CV= (TotalBiomass_sd/TotalBiomass_mean) *100) %>%
  ggplot(aes(x= thisLat , y=CV)) +  
  geom_point()

workDF %>%
  group_by(thisSow, thisHyb) %>%
  summarise_each(funs(sd, mean)) %>%
  select(thisSow, thisHyb,TotalBiomass_sd, TotalBiomass_mean) %>%
  mutate(CV= (TotalBiomass_sd/TotalBiomass_mean) *100) %>%
  ggplot(aes(x= thisHyb , y=CV)) +  
  geom_bar(stat='identity') +
  facet_grid( .~ thisSow)

# map CVs

mapDf <- workDF %>%
#  select(thisLat, thisLong, thisSow, thisHyb, TotalBiomass) %>%
  group_by(row, col, thisLat, thisLong) %>%
  summarise_each(funs(sd, mean)) %>%
  select(thisLat, thisLong,TotalBiomass_sd, TotalBiomass_mean) %>%
  mutate(CV= (TotalBiomass_sd/TotalBiomass_mean) *100)
head(mapDf)
par(mfrow = c(1,1))
outNames <- colnames(mapDf) # Using maximum grain yield

outNames <- gsub(" ","",outNames )

# ignore first 6 factors
spg <- list() # dataframe list to be coerced as spatial object
rast <- list() # raster
s <- list()

for(o in 3:length(outNames)){
  # For each variable aggregation
  spg[[o]] <- data.frame(mapDf$thisLong, mapDf$thisLat, mapDf[[o]])
  coordinates(spg[[o]]) <- ~ mapDf.thisLong + mapDf.thisLat # Attention to variable names
 
  # Common to both methods (grid, raterise and project)
  gridded(spg[[o]]) <- TRUE
  rast[[o]] <- raster(spg[[o]])
  proj4string(rast[[o]]) <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"

 plot(rast[[o]], main = paste0("Var: ", outNames[o]))

  # stack them
  if(o == 1) {
    s <- stack(rast[[o]])} # create stack
  else {
    s[[o]] <- rast[[o]]
  }
  
  # save raster as
  writeRaster(rast[[o]], file=paste0(outNames[o],"_CV",".tiff"), overwrite=TRUE) 
}

```


```{r DrivingFactors}
# Factors explaining variability
workDF %>%
group_by(thisSow, thisHyb) %>%
select(thisSow, thisHyb,IntRadSum, TotalBiomass ) %>%
summarise_each(funs(mean)) %>%
ggplot(aes(x= IntRadSum , y=TotalBiomass, colour = factor(thisSow))) +
geom_smooth(method=lm) +  
geom_point(aes(shape = thisHyb, size = 1)) +
  theme(text = element_text(size=25)) 
```


## Values pooled (median, mean, stdev) across **years** 

> Statistics of n years per pixel/scenario of hybrid and sow date combination

> Also creates a ID for each pixel-h-s combination (FIXME: maybe redundant now)

```{r CreateMedCV_df, echo = FALSE}
# Create a median and stdev for each pixel-h-s, polled across YEARS (i.e. year is not included in grouping)

workDF_med <- workDF %>%
  group_by(row,col,pixel_ID, thisHyb,thisSow) %>%
  summarise( thisLat = mean(thisLat, na.rm = TRUE),
             thisLong = mean(thisLong, na.rm = TRUE),
             thisRegion = mean(region),
             Bio_mean = mean(TotalBiomass, na.rm = TRUE),
             Bio_med = median(TotalBiomass, na.rm = TRUE),
             Bio_sdv = sd(TotalBiomass, na.rm = TRUE),
             Bio_cv = (Bio_sdv/Bio_mean)*100,
             Y_mean = mean(TotalYield, na.rm = TRUE),
             Y_med = median(TotalYield, na.rm = TRUE),
             Y_sdv = sd(TotalYield, na.rm = TRUE),
             Y_cv = (Y_sdv/Y_mean)*100,
             HI_med = median(HarvestIndex, na.rm = TRUE)) %>%
             mutate(scenID = paste0(thisHyb,"_",thisSow)) %>%
             mutate(pixel_scenID=paste0(row,"_",col,"_",thisHyb,"_",thisSow))  

# make hybrid and sow date as numbers (for using in raster later) 
# FIXME: do this in a prettier way later
workDF_med$thisSow_n[workDF_med$thisSow == "s1"] <- 1
workDF_med$thisSow_n[workDF_med$thisSow == "s2"] <- 2
workDF_med$thisSow_n[workDF_med$thisSow == "s3"] <- 3
workDF_med$thisSow_n[workDF_med$thisSow == "s4"] <- 4
workDF_med$thisSow_n[workDF_med$thisSow == "s5"] <- 5

workDF_med$thisHyb_n[workDF_med$thisHyb == "h1"] <- 1
workDF_med$thisHyb_n[workDF_med$thisHyb == "h2"] <- 2
workDF_med$thisHyb_n[workDF_med$thisHyb == "h3"] <- 3
workDF_med$thisHyb_n[workDF_med$thisHyb == "h4"] <- 4
workDF_med$thisHyb_n[workDF_med$thisHyb == "h5"] <- 5

head(workDF_med)
tail(workDF_med)

```


## Find hybrid x sow date with **highest yield** in each pixel

> This is to check the data "sensibility"

> FIXME: Check this dplyr script and logic as it seems that almost  **NO variation** is coming from this 

> Most productive sowing dates are **S1 (Sept) and S2 (Oct) **

> Most productive is always **hybrid 5** (longest hybrid)


```{r FindHighBio, echo=FALSE}
# select line with maximum biomass per pixel
df_maxBio <- workDF_med %>% 
  group_by(row, col) %>%
 # mutate(coord_code = paste0(thisHyb,"_",thisSow)) %>%
  filter(Bio_med == max(Bio_med))

# highest yield
df_maxY <- workDF_med %>% 
  group_by(row, col) %>%
#  mutate(coord_code = paste0(thisHyb,"_",thisSow)) %>%
   filter(Y_med == max(Y_med))

# lowest CV
df_minSd <- workDF_med %>% 
 group_by(row, col) %>%
#mutate(coord_code = paste0(thisHyb,"_",thisSow)) %>%
 filter(Bio_cv == min(Bio_cv))



#PLot histograms
hg1 <- ggplot(df_maxBio, aes(x=scenID)) + geom_histogram(binwidth=.5, colour="black", fill="white")
hg2 <- ggplot(df_maxY, aes(x=scenID)) + geom_histogram(binwidth=.5, colour="black", fill="white")
hg3 <- ggplot(df_minSd, aes(x=scenID)) + geom_histogram(binwidth=.5, colour="black", fill="white")


# Plot (pixels with highest yield in each category of sowing date and hybrid)
grid.arrange(hg1, hg2,hg3, ncol=3)
```

# How is total biomass and inter-annual variability related?

> In general **highest** yields have **lowest variability**

```{r BioVsCv, echo=FALSE}

workDF_med$Bio_meanTons <- workDF_med$Bio_mean / 1000 # convert kg/ha to t/ha

#different panels by hybrid
workDF_med %>%
ggplot(aes(x= Bio_meanTons , y=Bio_cv)) +  
geom_point(aes(colour = factor(thisRegion )) ) +
facet_grid(thisSow ~thisHyb, scales="free")

```

# Rasterise for mapping

> Checking data-frame

> Plot statistics for n Years 

## Pixels with highest Total Silage Biomass

> Maps show stats and which hybrid and sowing date was selected in each pixel

```{r MapsHighYield, echo=FALSE, warning=FALSE, include = FALSE}

df_maxY <- df_maxY %>% filter(thisHyb != "h2"| thisHyb != "h4"| thisSow != "s1"| thisSow != "s5")

mapDf <- workDF %>% 
  select(pixel_ID, thisLat, thisLong, TotalBiomass) %>%
  group_by(pixel_ID)  %>% 
  summarise(Bio_mean = mean(TotalBiomass, na.rm = TRUE), Bio_sd = sd(TotalBiomass, na.rm = TRUE))  %>% 
  mutate(Bio_cv = (Bio_sd/Bio_mean*100)) - # FIXME: not finished

par(mfrow = c(1,1))
outNames <- colnames(mapDf) # Using maximum grain yield

outNames <- gsub(" ","",outNames )

# ignore first 6 factors
spg <- list() # dataframe list to be coerced as spatial object
rast <- list() # raster
s <- list()

for(o in 2:length(outNames)){
if (o == 12) {next} # other label to ignore (FIXME: Still selected by hand)

  # For each variable aggregation
  spg[[o]] <- data.frame(mapDf$thisLong, mapDf$thisLat, mapDf[[o]])
  coordinates(spg[[o]]) <- ~ mapDf.thisLong + mapDf.thisLat # Attention to variable names
 
  # Common to both methods (grid, raterise and project)
  gridded(spg[[o]]) <- TRUE
  rast[[o]] <- raster(spg[[o]])
  proj4string(rast[[o]]) <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"

 plot(rast[[o]], main = paste0("Var: ", outNames[o]))

  # stack them
  if(o == 1) {
    s <- stack(rast[[o]])} # create stack
  else {
    s[[o]] <- rast[[o]]
  }
  
  # save raster as
  writeRaster(rast[[o]], file=paste0(outNames[o],"_var",".tiff"), overwrite=TRUE) 
}

```

Test yield over time

```{r YieldChangeTime}

# Is yield potential changing in past 30 years?
# FIXME: not working now
slopesDF <- NULL
slopesDF <- workDF %>%
 select (pixel_ID, thisSow, thisHyb, thisLat, thisLong, TotalBiomass, year) %>%
 group_by(pixel_ID, thisSow, thisHyb) %>%
# filter(TotalBiomass > 100) %>%
 do(mod = lm(TotalBiomass ~ year, data = .)) %>%
  mutate(Slope = coef(mod)[2], 
         Intercept = coef(mod)[1], 
         Pval = coef(mod)[8]) %>%
  filter (Pval <= 0.05) %>% # select pixels with significant slope
  select(-mod)
  head(slopesDF)

# Try data table
library(data.table)
setDT(workDF)[, list(Slope = summary(lm(TotalBiomass ~ year))$coeff[2]),  pixel_ID] # how to agregate by many

  #FIXME: this merge is multiplying unecesary pixels
  slopesDF <- workDF %>%
 # select(pixel_ID, thisSow, thisHyb, TotalBiomass, thisLat, thisLong) %>%
  group_by(pixel_ID, thisSow, thisHyb) %>%
  summarise_each(funs(mean)) %>%
  merge(slopesDF, by = c("pixel_ID", "thisSow", "thisHyb"))

# slopesDF <- merge(slopesDF, xx, by = c("pixel_ID", "thisSow", "thisHyb"))

```


```{r SlopeAnalysis}
slopesDF %>%
  select(thisSow, thisHyb, slope) %>%
  ggplot(aes(x=thisSow, y=slope)) +
  geom_boxplot() +
  geom_jitter(aes(colour = thisHyb))


slopesDF %>%
  select(thisLat, thisSow, thisHyb, slope) %>%
  ggplot(aes(x=thisLat, y=slope)) +
  geom_point(aes(colour = thisHyb)) +
  facet_grid(thisSow~.)

head(slopesDF)

# Test some pixels
workDF %>%
filter(pixel_ID == "149_131" & TotalBiomass > 100) %>%
select(year, TotalBiomass, thisSow, thisHyb) %>%
ggplot(aes(x= year , y=TotalBiomass)) +  
geom_smooth(method=lm) +  
geom_point() +
facet_grid(thisHyb ~ thisSow)


```

Map slope

```{r MapYieldSlope}

# map the pixels with change 

spg <- list() # dataframe list to be coerced as spatial object
rast <- list() # raster
s <- list()
sow <- c("s1", "s2", "s3", "s4", "s5")
hyb <- c("h1", "h2", "h3", "h4", "h5")
count <- 0
par(mfrow=c(1,2))
for(s in 1:length(sow)) {
  for(h in 1:length(hyb))  {
  count <- count + 1  
  
  mapDF <- slopesDF %>%
  subset(thisSow == sow[s] & thisHyb == hyb[h])
    
  # For aggregate
  spg[[count]] <- data.frame(mapDF$thisLong, mapDF$thisLat, mapDF$slope)
  coordinates(spg[[count]]) <- ~ mapDF.thisLong + mapDF.thisLat # Attention to variable names
  
  # Common to both methods (grid, raterise and project)
  gridded(spg[[count]]) <- TRUE
  rast[[count]] <- raster(spg[[count]])
  proj4string(rast[[count]]) <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"
  
  plot(rast[[count]], main = paste0(sow[s]," ",hyb[h]))
  writeRaster(rast[[count]], file=paste0("Slope_", paste0(sow[s],"_",hyb[h],".tiff")), overwrite=TRUE) 
 
  
    }
  }
```
