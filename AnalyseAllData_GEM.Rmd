---
title: "AnalyseGEM"
author: "edmar.teixeira@me.com"
date: "Sunday, December 07, 2014"
output: html_document
---

# Background

## Aim

Quantify **uncertanty** (sensitivity of model to?) coming from the choice of (possible?) **sowing dates and maize hybrids** in regional simulations

## Method

> Use APSIM 7.4

> Run model for ~2700 pixels of 5 x 5 km (NIWA ref XXX) across New Zealand

> Arable land filter frpm LandCare (ref XXX)

> Run 30 years (XXX-XXXX) of data from NIWA (XXXX)

> Run 5 hybrid maturity types (parameter XXXX with values x, x, x, x, x)

> Run at 5 different sowng dates (1-Sep, 1-Oct, 1-Nov, 1-Dec, 1-Jan)


# Data Manipulation

```{r LoadLibs, echo=TRUE, include=FALSE}
gc()
library(ggplot2)
library(plot3D)
library(gridExtra)
library(tidyr)
library(raster)
library(mapproj)
library(dplyr)
library(knitr)
```

## Retrieve data and check
```{r GetData, include=FALSE}
# load data from HD
#setwd("E:\\SowByGenotype")
setwd("C:\\Apsim_dev\\Projects\\2014-SowByGenotype\\GEM_data")
#setwd("C:\\Apsim_dev\\Projects\\2014-SowByGenotype\\outFiles")

load("DATA_GEM.Rda", .GlobalEnv)


head(DATA_GEM)
tail(DATA_GEM)
summary(DATA_GEM)

print(paste0("Found ", length(unique(DATA_GEM$row)), " rows"))
print(paste0("Found ", length(unique(DATA_GEM$col)), " cols"))
print(paste0("Found ", length(unique(DATA_GEM$row * DATA_GEM$col)), " pixels"))

```

> Subset to keep only maize (exclude winter forage wheat) and order factors

```{r TidyUp, echo = FALSE, include=FALSE}
# Remove wheat (catch crop rotation) and keep only maize data
workDF <- NULL
workDF <- subset(DATA_GEM, CurrentCrop != 'wheat_exceed')

# order sow dates
workDF$thisSow <- factor(workDF$thisSow, levels = c('s1', 's2', 's3', 's4', 's5'))
workDF$thisHyb <- factor(workDF$thisHyb, levels = c('h1', 'h2', 'h3', 'h4', 'h5'))
#workDF$thisSow <- factor(workDF$thisSow, levels = c('s1', 's2', 's3', 's4'))
#workDF$thisHyb <- factor(workDF$thisHyb, levels = c('h1', 'h2', 'h3', 'h4'))


#creates ID for each pixel
workDF$pixel_ID <- paste0(workDF$row,"_",workDF$col)
print(paste0("Found ", length(unique(workDF$pixel_ID)), " pixels"))
inPix <- length(unique(workDF$pixel_ID))


# Creates a year field as factor
workDF$yearAsFact <- as.factor(paste0(workDF$year,"_Y"))

# Average TT accumulation per day of regrowth (proxy for average Temp during cycle) 
workDF <- workDF %>%  mutate(TTav = TTsum/GrowthLength)

summary(workDF)

# Read region data
#df_region <- as.data.frame(read.csv(file = 
#                                        paste0("C:\\Apsim_dev\\Projects\\2014-SowByGenotype\\GEM_data\\",
#                                   "RegionPerPixel.csv") ))
nrow(df_region)
head(df_region)
#df_region <- df_region %>% group_by(row,col,regNames) %>% select (-X, -record)
#df_region <- data.frame(df_region)
head(df_region)

#workDF <- merge(workDF, df_region, by = c("row", "col")) # FIXME: this is deleting some pixels
# FIXME: region merge is deleting Canterbury latitude
 
head(workDF)

# Read climate zone data
climZones <- NULL
climZones <- read.csv("C:\\Apsim_dev\\Projects\\2014-SowByGenotype\\GEM_data\\CLuster.csv")
head(climZones)
nrow(climZones)

# Corercting coordinates FIXME: Check that
climZones$row <- climZones$row + 1 # climZones[,rowNew] - 1
climZones$col <- climZones$col + 1 # climZones[,colNew] - 1
climZones$pixel_ID2 <- paste0(climZones$row,"_",climZones$col)
head(climZones)
nrow(climZones)

# pixels in each DF
length(unique(climZones$pixel_ID)) # FIXME: where are thse coming from?
length(unique(workDF$pixel_ID)) # FIXME: where are thse coming from?

# merge DFs FIXME: merge is deleting many pixels
workDF <- merge(workDF,climZones, by = c("row", "col")) # FIXME: this is deleting some pixels
#workDF <- merge(workDF,climZones, by = "pixel_ID") # FIXME: this is deleting some pixels
length(unique(workDF$pixel_ID)) # FIXME: where are thse coming from?


length(unique(climZones$pixel_ID)) # FIXME: where are thse coming from?
length(unique(workDF$pixel_ID)) # FIXME: where are thse coming from?

workDF$Combine <- factor(workDF$Combine, levels = c('LTLR', 'LTMR', 'LTHR','MTLR','MTMR', 'MTHR','HTLR', 'HTMR', 'HTHR'))
head(climZones)

#write.table(climZones, file="climZones.txt"), row.names=FALSE, col.names=TRUE, sep=" ",
#               append=FALSE, quote=FALSE)

# Give numeric labels to factor levels
workDF$thisSow_n[workDF$thisSow == "s1"] <- 1
workDF$thisSow_n[workDF$thisSow == "s2"] <- 2
workDF$thisSow_n[workDF$thisSow == "s3"] <- 3
workDF$thisSow_n[workDF$thisSow == "s4"] <- 4
workDF$thisSow_n[workDF$thisSow == "s5"] <- 5

workDF$thisHyb_n[workDF$thisHyb == "h1"] <- 1
workDF$thisHyb_n[workDF$thisHyb == "h2"] <- 2
workDF$thisHyb_n[workDF$thisHyb == "h3"] <- 3
workDF$thisHyb_n[workDF$thisHyb == "h4"] <- 4
workDF$thisHyb_n[workDF$thisHyb == "h5"] <- 5

summary(workDF)
head(workDF)
enPix <- length(unique(workDF$pixel_ID))
print(paste0("Found ", length(unique(workDF$pixel_ID)), 
             " pixels and change in pixel # (if any) was ",inPix - enPix))
save(workDF,file="workDF_GEM.Rda")

```

Get pooled values per climatic zones

```{r TableResClimZone}

workDF %>%
  group_by(Combine) %>%
  select(TotalBiomass, HarvestIndex) %>%
  mutate(TotalBiomass_Mg = TotalBiomass/1000) %>%
  summarise_each(funs(mean, sd)) %>%
  mutate(Bio_CV = ((TotalBiomass_Mg_sd/TotalBiomass_Mg_mean)*100), 
                   HI_CV = ((HarvestIndex_sd/HarvestIndex_mean)*100))  %>%
  select(Combine,TotalBiomass_Mg_mean, Bio_CV, HarvestIndex_mean,HI_CV) %>%
  kable( format = "markdown")

workDF %>%
  select(TotalBiomass, HarvestIndex) %>%
  summarise_each(funs(mean))%>%
  kable( format = "markdown")

# Area in Kha 
workDF %>%
  group_by(Combine) %>%
  select(pixel_ID) %>%
  summarise(Unique_Pixels = n_distinct(pixel_ID)) %>%
  mutate(apr_area_kha = Unique_Pixels * 2500/1000) %>%
  kable( format = "markdown")


```

Select some pixels across the range of results for 3D graph

```{r 3DGraphsByPixel, echo = FALSE}

df_sel <- workDF %>%
  group_by(Combine, row,col, pixel_ID, thisSow_n, thisHyb_n) %>%
  summarise(bio = mean(TotalBiomass), hi = mean(HarvestIndex))  %>%
  filter(pixel_ID == "24_157" | pixel_ID == "189_106" | pixel_ID == "240_45") %>%
    write.table(file=paste0("3D_graph.txt"), 
                row.names=FALSE, col.names=TRUE, sep=" ", append=FALSE, quote=FALSE)
 # count(Combine,bio,hi) %>%
 # filter(bio == max(bio)) %>%
 # filter(Combine == "LTLR" | Combine == "MTMR"| Combine == "HTHR" ) %>%

pixels <- unique(df_sel$pixel_ID)

```

Box plots for selected climate zones

```{r BoxPlotsClimZone}

# Pooled response to Hybrid (Bio)
# Total biomass
workDF %>%
filter(Combine == "LTLR"  | Combine == "HTHR")  %>%
ggplot(aes(x= thisHyb , y=TotalBiomass)) +  
geom_violin() +
geom_boxplot(aes(alpha = 0.5)) +
facet_grid(Combine ~ thisSow) +
xlab("Hybrid maturity") +
ylab("Total biomass (kg/ha)") +
theme(text = element_text(size=25)) + 
theme(legend.position = "none") 
ggsave(file="TotBio_boxplot.tiff", dpi = 300)

# Total Yield
# Total biomass
workDF %>%
filter(Combine == "LTLR" | Combine == "MTMR" | Combine == "HTHR")  %>%
ggplot(aes(x= thisHyb , y=TotalYield)) +  
geom_violin() +
geom_boxplot(aes(alpha = 0.5)) +
facet_grid(Combine ~ thisSow) +
xlab("Grain yield (kg/ha)") +
ylab("Total biomass (kg/ha)") +
theme(text = element_text(size=25)) + 
theme(legend.position = "none") 
ggsave(file=paste0("Grain_boxplot.tiff"), dpi = 300)

# Harvest Index
# Total biomass
workDF %>%
filter(Combine == "LTLR" | Combine == "HTHR")  %>%
ggplot(aes(x= thisHyb , y=HarvestIndex)) +  
geom_violin() +
geom_boxplot(aes(alpha = 0.5)) +
facet_grid(Combine ~ thisSow) +
xlab("Hybrid maturity") +
ylab("Harvest index (fractional)") +
theme(text = element_text(size=25)) + 
theme(legend.position = "none") 
ggsave(file="HI_boxplot.tiff", dpi = 300)

```

## Calculate the relative variability for factors

> How much of overall variation is coming from sowing date, hybrid and their interaction?

> Adapting Esther Meenken method of sensitivity analysis for that

> Run a ANOVA and retrive the Sums of Squares (SS) of each factor (3 main factors and the interaction)

> Display it as a relative proportion of total variation (% of total SS)

> This is the **Si index** summary:

```{r ANOVA, echo =FALSE}
# do an anova for each pixel 
# This loop takes ages!

si_df_final <- NULL
pixels <- unique(workDF$pixel_ID)

summary(workDF) # Should I use workDF?
head(workDF)

vars <- c("TotalBiomass", "HarvestIndex")

# FIXME: Loop is too slow - do this later with dplyr or something better

for (v in 1:length(vars)) {
# for (p in 1:length(pixels)) {
  for (p in 1:10) { # test

  thisPixDF <- workDF %>%
    filter(pixel_ID == pixels[[p]]) %>%
    group_by(thisHyb, thisSow, yearAsFact, row, col, thisLat, thisLong, Combine) %>% # to avoid crops that are harvested in same year (for anova)
    select(TotalBiomass, HarvestIndex) %>%
    summarise_each(funs(mean))

  write.table(thisPixDF, file = "test.txt")
  head(thisPixDF)
  summary(thisPixDF)

  # do anova (FIXME: do more elegant)
  if (vars[v] == "TotalBiomass") {
  anova <- aov(TotalBiomass ~ thisHyb*thisSow*yearAsFact, data = thisPixDF)
  } else if (vars[v] == "HarvestIndex") {
  anova <- aov(HarvestIndex ~ thisHyb*thisSow*yearAsFact, data = thisPixDF)
  }

  anovaTable <- summary(anova)
  anovaTable
  
  #Retrive SS and MS values
  anova_SS <- anovaTable[[1]]$'Sum Sq'
 # anova_MS <- anovaTable[[1]]$'Mean Sq' 

  # Binds all SS for each variable together into a new df
 # df_ss <- data.frame(SS = anova_SS, MS = anova_MS)
  df_ss <- NULL
  df_ss <- data.frame(SS = anova_SS)

  #retrieves row names and load into result df
  namesAnTab <- rownames(anovaTable[[1]])
  rownames (df_ss) <- gsub(" ","",namesAnTab) # remove spaces
 
 # get names and count of main factors
 mainFactNames <- rownames (df_ss)[-grep(':',rownames (df_ss))] # isolate the main factors from
 noFactors <- length(mainFactNames)  # counts row names that do not have ":" i.e. from interaction
 
 # Creates a column with "normalised" percent of total variation (SS) 
  # in relation to total SS for each factor in that pixel
  df_ss$SS_p <- round((df_ss$SS/sum(df_ss$SS))*100,3)
  # df_ss$MS_p <- round((df_ss$MS/sum(df_ss$MS))*100,3) 
  # FIXME: Not sure which to use SS or MS - Esther Menkeen suggested SS
 
# Add SS of interections as a new vector element that adds to 100%
sumInt <- sum(df_ss$SS_p[(noFactors+1):length(namesAnTab)]) # Calculate sums total SS due to interactions (i.e. sums every SS that is not main factor)
si_Out1 <- c(df_ss$SS_p[1:noFactors], sumInt) # vector with si values in %

# test anova
if (sum(si_Out1) < 99.9 | sum(df_ss$SS_p) > 100.1) {
  print("Check your ANOVA")
  print(paste0("Sum of all % of Si: ", sum(df_ss$SS_p))) # check it
  }

# Create the Si dataframe and graph it
df_si <- data.frame(si_Out1)
rownames(df_si) <- gsub(" ","",c(mainFactNames[1:noFactors], "Interactions"))

df_si$FactorName <- rownames(df_si)
colnames(df_si) <- c("PercTotal_SS", "FactorName") 

  # FIXME: Not sure which to use SS or MS - Esther Menkeen suggested SS
  df_si <- data.frame(thisLat = thisPixDF$thisLat[1],
                   thisLong = thisPixDF$thisLong[1],
                #   thisRegion = thisPixDF$region[1],
                   thisClimZone = thisPixDF$Combine[1],
                   thisVar = vars[v],
                   row = thisPixDF$row[1],
                   col = thisPixDF$col[1],
                   si_Out1[1], 
                   si_Out1[2], 
                   si_Out1[3],
                   si_Out1[4]
                   )
 
 noLabels <- 6 # FIXME: do it prittier later

  # label Si df FIXME: Automate this
  colnames(df_si)[noLabels+1] <- gsub(" ","",paste0("Si_",mainFactNames[1]))
  colnames(df_si)[noLabels+2] <- gsub(" ","",paste0("Si_",mainFactNames[2]))
  colnames(df_si)[noLabels+3] <- gsub(" ","",paste0("Si_",mainFactNames[3]))
  colnames(df_si)[noLabels+4] <- "Si_Interac"
  
  # Appends to final Si df
  if(p==1 & vars[v] == 1){ 
    si_df_final <- data.frame(df_si)  
    } else {
    si_df_final <- rbind(si_df_final, df_si)
    }
 print(paste0("In pixel ",p))
}

head(si_df_final)
nrow(si_df_final)

# Graph Si for eacj main factor and interaction
#gH <- ggplot(si_df_final, aes(x=Si_thisHyb)) + geom_histogram(binwidth=.5, colour="black", fill="white")
#gS <- ggplot(si_df_final, aes(x=Si_thisSow)) + geom_histogram(binwidth=.5, colour="black", fill="white")
#gW <- ggplot(si_df_final, aes(x=Si_yearAsFact)) + geom_histogram(binwidth=.5, colour="black", fill="white")
#gI <- ggplot(si_df_final, aes(x=Si_Interac)) + geom_histogram(binwidth=.5, colour="black", fill="white")

si_df_final_m <- si_df_final # place holder while we decide what to do with region

head(si_df_final_m)

} # end loop in variables


# Plot results ---------------


# save this DF 
write.table(si_df_final_m, file=paste0("Si_by_Pixel.txt"), row.names=FALSE, col.names=TRUE, sep=" ",append=FALSE, quote=FALSE)

# ---- All plotted together by clim zone -------------------------

fontSize <- 20
si_df_final_m %>%
 # subset(thisRegion == 3 | thisRegion == 6 | thisRegion == 13 | thisRegion == 14) %>%
  group_by(thisLat, thisLong) %>%
  gather(factName, siVal, 6:9) %>% # FIXME: this might change - can you automate?
  ggplot(aes(x= siVal, colour=factName, fill=factName)) + 
  geom_histogram(aes(y=..density..), binwidth=.8, alpha=0) +
 # geom_histogram(binwidth=1, alpha=0) +
  geom_density(alpha=0.2,size=1.5) +
 # facet_grid(thisRegion~. , scales="free") +
  facet_wrap(~thisClimZone, scales="free") +
  xlab("Percent of total variability (%)") +
  ylab("Frequency distribution") +
  theme(text = element_text(size=fontSize)) + 
  theme(legend.position = "none")
  ggsave(file=paste0(vars[v],"_Si_ClimZone_hist.tiff"), dpi = 300)
  #theme(legend.position = c(0, 1), 
  #     legend.justification = c(-1, 1)) 
 # scale_fill_discrete(name="Factors", labels=c("Hybrids","Sowing date","Weather", "Interactions")) +

# Plot distributions of Si
#grid.arrange(gH, gS, gW,gI, nrow=4)
#si_df_final_m_bkp <- si_df_final_m


# Bar graph version (pooled by climate zones) --------------

df_av <- si_df_final_m %>% group_by(thisClimZone) %>% summarise_each(funs(mean)) %>% gather(factName, siVal, 6:9)

si_df_final_m %>%
  group_by(thisClimZone) %>%
  summarise_each(funs(mean)) %>%
  mutate (Si_tot = Si_thisHyb + Si_thisSow + Si_yearAsFact + Si_Interac) %>%
  mutate (Si_thisHyb = Si_thisHyb/Si_tot*100, 
          Si_thisSow = Si_thisSow/Si_tot*100, 
          Si_yearAsFact = Si_yearAsFact/Si_tot*100, 
          Si_Interac = Si_Interac/Si_tot*100) %>%
  gather(factName, siVal, 6:9) %>%
  ggplot(aes(x=thisClimZone, y=siVal, fill=factName, order=rev(factName))) + 
  geom_bar(stat='identity')  +
  xlab("Climatic zones ") + ylab("Share of total variability (%)") + 
 # scale_x_discrete(labels= ) + 
  scale_fill_discrete(name="Factor",
                         labels=c("Hybrid", "Sowing dates", "Weather" , "Interactions"))+
  theme(text = element_text(size=20)) +
  theme(axis.text.x = element_text(angle = 45, hjust=1)) # +
 # geom_text(aes(label = paste0("(",round(df_av$siVal, digits=1),"%)"), y=mean(siVal)), size = 7) +
 # ggsave(file="Fig_Ti.tiff", dpi = 300)
  ggsave(file=paste0(vars[v],"_Si_barGraph.tiff"), dpi = 300)

```


> Histograms show frequency of pixels in each range of Si for each factor and interactions


```{r SiAnalysis}

weatherPixel <- 
  read.csv("F:\\ERA-40_Reanalysis\\metFiles_ERA_1971_2000\\SummaryResults\\RasterOutput_base.csv")

weatherPixel <- data.frame(weatherPixel)
head(weatherPixel)
summary(weatherPixel)
weatherPixel <- weatherPixel %>% select(-thisLat, -thisLong) # unnecessary cols and dulicates at merge

si_weather_merged <- NULL
si_weather_merged <- merge(si_df_final_m, weatherPixel, by = c("row","col"))
si_weather_merged <- si_weather_merged %>% mutate(meant = (maxt+mint)*0.5)
head(si_weather_merged)

# "year  day  maxt	mint	radn	rain	co2"

# Graph now
si_weather_merged %>%
  gather(factName, siVal, 6:9) %>% # FIXME: this might change - can you automate?
  mutate(cyl = factor(siVal, levels = c("Hybrid maturity", "Sowing date", "Weather", "Interactions"))) %>%
  ggplot(aes(x=meant, y=siVal)) +
  geom_point(aes(colour = thisClimZone)) +
 # geom_smooth(method=lm) +
  theme(text = element_text(size=20)) +
  xlab("Average annual temperature (^oC)") +
  ylab("Sensitivity index (Si, % total variability)") +
  facet_wrap(~factName, scales = "free") + 
  scale_fill_discrete(name="Climatic zones")
  ggsave(file=paste0(vars[v],"_Si_barGraph.tiff"), dpi = 300)

```




## Map Si index

> Si is the fraction of total sums of squares attributed to each main factor or interactions

> Let's plot it: 

```{r MapSi, echo = FALSE, warning=FALSE}
outNames <- colnames(si_df_final)
outNames <- gsub(" ","",outNames )
#par(mfrow=c(1,(length(mainFact)+1)))
par(mfrow=c(2,2))

# ignore first 6 factors
spg <- list() # dataframe list to be coerced as spatial object
rast <- list() # raster
s <- list()


# FIXME: This is by hand now
factNames <- c("Region", "Latitude","Longitude", "Si Hybrid","Si Sow date", "Si Weather", "Si Interactions", "Regions")

# TODO: add a region code and then plot it for each region in the loop
for(o in length(mainFactNames):length(outNames)){

  # For aggregate
  spg[[o]] = data.frame(si_df_final$thisLong, si_df_final$thisLat, si_df_final[[o]])
  coordinates(spg[[o]]) = ~ si_df_final.thisLong + si_df_final.thisLat # Attention to variable names
 
  # Common to both methods (grid, raterise and project)
  gridded(spg[[o]]) <- TRUE
  rast[[o]] <- raster(spg[[o]])
  proj4string(rast[[o]]) <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"

  # stack them
  if(o == 1) {
    s <- NULL
    s <- stack(rast[[o]])} 
  else {
    s[[o]] <- rast[[o]]
  }
  
  
  # plot them
  if (o %in% 4:7) {
    plot(rast[[o]], main = paste0(factNames[o]))
    
    # save raster as
    writeRaster(rast[[o]], file=paste0("Si_", outNames[o],".tiff"), overwrite=TRUE) 

  }
   
  # map('nz')
}
#map(database= "usa", col="#FFFFFF", fill=FALSE,add=TRUE, lwd=1.5)

```



## Graph some results

> Total silage biomass by sowing date (kg/ha)

```{r GraphBySow, echo=FALSE}

# Pooled pixels response to sow date by hybrid

# Total biomass
workDF %>%
#subset(region == 4 |region == 11 | region == 13) %>%
ggplot(aes(x= thisSow , y=TotalBiomass)) +  
geom_boxplot() +
#facet_grid(region ~ thisHyb)
facet_grid(. ~ thisHyb)

# Total Yield
workDF %>%
#subset(region == 4 |region == 11 | region == 13) %>%
ggplot(aes(x= thisSow , y=TotalYield)) +  
geom_boxplot() +
#facet_grid(region ~ thisHyb)
facet_grid(row~ thisHyb)

# Harvest Index
workDF %>%
ggplot(aes(x= thisSow , y=HarvestIndex)) +  
geom_boxplot() +
facet_grid( .~ thisHyb)

# Water Use
workDF %>%
ggplot(aes(x= thisSow , y=ETact)) +  
geom_boxplot() +
facet_grid( .~ thisHyb)

# Water Use Efficiency
workDF %>%
ggplot(aes(x= thisSow , y=WUE)) +  
geom_boxplot() +
facet_grid( .~ thisHyb)

# Radiation use Efficiency
workDF %>%
ggplot(aes(x= thisSow , y=RUEtop)) +  
geom_boxplot() +
facet_grid( row~ thisHyb)


# Light Interception
workDF %>%
ggplot(aes(x= thisSow , y=IntRadSum)) +  
geom_boxplot() +
facet_grid( row~ thisHyb)


```

> Total silage biomass by hybrid type (kg/ha)

This form of display seems more interesting.

- Advantege of long hybrids is reduced at late sowing dates

```{r GraphByHyb, echo = FALSE}

# Pooled response to Hybrid (Bio)
# Total biomass
workDF %>%
#subset(region == 4 |region == 11 | region == 13) %>%
#subset(thisSow == "s5") %>%
ggplot(aes(x= thisHyb , y=TotalBiomass)) +  
geom_boxplot() +
#facet_grid( region~ thisSow)
facet_grid(. ~ thisSow)# +
#facet_wrap(~Combine, ncol = 3)

# Total Yield
workDF %>%
ggplot(aes(x= thisHyb , y=TotalYield)) +  
geom_boxplot() +
facet_grid( row~ thisSow)

# Harvest Index
workDF %>%
ggplot(aes(x= thisHyb , y=HarvestIndex)) +  
geom_boxplot() +
facet_grid( row~ thisSow)

# Water Use
workDF %>%
ggplot(aes(x= thisHyb , y=ETact)) +  
geom_boxplot() +
facet_grid( .~ thisSow)

# Water Use Efficiency
workDF %>%
ggplot(aes(x= thisHyb , y=WUE)) +  
geom_boxplot() +
facet_grid( .~ thisSow)

# Water Use Efficiency
workDF %>%
ggplot(aes(x= thisHyb , y=WUE)) +  
geom_boxplot() +
facet_grid( .~ thisSow)

```

# Analysis

## Calculate variability as CV%

> Just to have an initial idea of variability

> Considers variation among YEARS and PIXELS together

> Pooled among hybrids and sowing dates


```{r GraphCVs, echo =FALSE}
# polled CV across hybrids and sowing dates

workDF %>%
  group_by(thisLat,thisLong,thisSow, thisHyb) %>%
  summarise_each(funs(sd, mean)) %>%
  select(thisSow, thisHyb,thisLat,thisLong,TotalBiomass_sd, TotalBiomass_mean) %>%
  mutate(CV= (TotalBiomass_sd/TotalBiomass_mean) *100) %>%
  ggplot(aes(x= thisLat , y=TotalBiomass_mean)) + 
  geom_point() +
  facet_grid(.~ thisHyb)

workDF %>%
  group_by(row, col, thisLat, thisLong) %>%
  summarise_each(funs(sd, mean)) %>%
  select(thisLat,thisLong,TotalBiomass_sd, TotalBiomass_mean) %>%
  mutate(CV= (TotalBiomass_sd/TotalBiomass_mean) *100) %>%
  ggplot(aes(x= thisLat , y=CV)) +  
  geom_point()

workDF %>%
  group_by(thisSow, thisHyb) %>%
  summarise_each(funs(sd, mean)) %>%
  select(thisSow, thisHyb,TotalBiomass_sd, TotalBiomass_mean) %>%
  mutate(CV= (TotalBiomass_sd/TotalBiomass_mean) *100) %>%
  ggplot(aes(x= thisHyb , y=CV)) +  
  geom_bar(stat='identity') +
  facet_grid( .~ thisSow)

# map CVs

mapDf <- workDF %>%
#  select(thisLat, thisLong, thisSow, thisHyb, TotalBiomass) %>%
  group_by(row, col, thisLat, thisLong) %>%
  summarise_each(funs(sd, mean)) %>%
  select(thisLat, thisLong,TotalBiomass_sd, TotalBiomass_mean) %>%
  mutate(CV= (TotalBiomass_sd/TotalBiomass_mean) *100)
head(mapDf)
par(mfrow = c(1,1))
outNames <- colnames(mapDf) # Using maximum grain yield

outNames <- gsub(" ","",outNames )

# ignore first 6 factors
spg <- list() # dataframe list to be coerced as spatial object
rast <- list() # raster
s <- list()

for(o in 3:length(outNames)){
  # For each variable aggregation
  spg[[o]] <- data.frame(mapDf$thisLong, mapDf$thisLat, mapDf[[o]])
  coordinates(spg[[o]]) <- ~ mapDf.thisLong + mapDf.thisLat # Attention to variable names
 
  # Common to both methods (grid, raterise and project)
  gridded(spg[[o]]) <- TRUE
  rast[[o]] <- raster(spg[[o]])
  proj4string(rast[[o]]) <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"

 plot(rast[[o]], main = paste0("Var: ", outNames[o]))

  # stack them
  if(o == 1) {
    s <- stack(rast[[o]])} # create stack
  else {
    s[[o]] <- rast[[o]]
  }
  
  # save raster as
  writeRaster(rast[[o]], file=paste0(outNames[o],"_CV",".tiff"), overwrite=TRUE) 
}

```


```{r DrivingFactors}
# Factors explaining variability
workDF %>%
group_by(thisSow, thisHyb) %>%
select(thisSow, thisHyb,IntRadSum, TotalBiomass ) %>%
summarise_each(funs(mean)) %>%
ggplot(aes(x= IntRadSum , y=TotalBiomass, colour = factor(thisSow))) +
geom_smooth(method=lm) +  
geom_point(aes(shape = thisHyb, size = 1)) +
  theme(text = element_text(size=25)) 
```


## Values pooled (median, mean, stdev) across **years** 

> Statistics of n years per pixel/scenario of hybrid and sow date combination

> Also creates a ID for each pixel-h-s combination (FIXME: maybe redundant now)

```{r CreateMedCV_df, echo = FALSE}
# Create a median and stdev for each pixel-h-s, polled across YEARS (i.e. year is not included in grouping)

workDF_med <- workDF %>%
  group_by(row,col,pixel_ID, thisHyb,thisSow) %>%
  summarise( thisLat = mean(thisLat, na.rm = TRUE),
             thisLong = mean(thisLong, na.rm = TRUE),
             thisRegion = mean(region),
             Bio_mean = mean(TotalBiomass, na.rm = TRUE),
             Bio_med = median(TotalBiomass, na.rm = TRUE),
             Bio_sdv = sd(TotalBiomass, na.rm = TRUE),
             Bio_cv = (Bio_sdv/Bio_mean)*100,
             Y_mean = mean(TotalYield, na.rm = TRUE),
             Y_med = median(TotalYield, na.rm = TRUE),
             Y_sdv = sd(TotalYield, na.rm = TRUE),
             Y_cv = (Y_sdv/Y_mean)*100,
             HI_med = median(HarvestIndex, na.rm = TRUE)) %>%
             mutate(scenID = paste0(thisHyb,"_",thisSow)) %>%
             mutate(pixel_scenID=paste0(row,"_",col,"_",thisHyb,"_",thisSow))  

# make hybrid and sow date as numbers (for using in raster later) 
# FIXME: do this in a prettier way later
workDF_med$thisSow_n[workDF_med$thisSow == "s1"] <- 1
workDF_med$thisSow_n[workDF_med$thisSow == "s2"] <- 2
workDF_med$thisSow_n[workDF_med$thisSow == "s3"] <- 3
workDF_med$thisSow_n[workDF_med$thisSow == "s4"] <- 4
workDF_med$thisSow_n[workDF_med$thisSow == "s5"] <- 5

workDF_med$thisHyb_n[workDF_med$thisHyb == "h1"] <- 1
workDF_med$thisHyb_n[workDF_med$thisHyb == "h2"] <- 2
workDF_med$thisHyb_n[workDF_med$thisHyb == "h3"] <- 3
workDF_med$thisHyb_n[workDF_med$thisHyb == "h4"] <- 4
workDF_med$thisHyb_n[workDF_med$thisHyb == "h5"] <- 5

head(workDF_med)
tail(workDF_med)

```


## Find hybrid x sow date with **highest yield** in each pixel

> This is to check the data "sensibility"

> FIXME: Check this dplyr script and logic as it seems that almost  **NO variation** is coming from this 

> Most productive sowing dates are **S1 (Sept) and S2 (Oct) **

> Most productive is always **hybrid 5** (longest hybrid)


```{r FindHighBio, echo=FALSE}
# select line with maximum biomass per pixel
df_maxBio <- workDF_med %>% 
  group_by(row, col) %>%
 # mutate(coord_code = paste0(thisHyb,"_",thisSow)) %>%
  filter(Bio_med == max(Bio_med))

# highest yield
df_maxY <- workDF_med %>% 
  group_by(row, col) %>%
#  mutate(coord_code = paste0(thisHyb,"_",thisSow)) %>%
   filter(Y_med == max(Y_med))

# lowest CV
df_minSd <- workDF_med %>% 
 group_by(row, col) %>%
#mutate(coord_code = paste0(thisHyb,"_",thisSow)) %>%
 filter(Bio_cv == min(Bio_cv))



#PLot histograms
hg1 <- ggplot(df_maxBio, aes(x=scenID)) + geom_histogram(binwidth=.5, colour="black", fill="white")
hg2 <- ggplot(df_maxY, aes(x=scenID)) + geom_histogram(binwidth=.5, colour="black", fill="white")
hg3 <- ggplot(df_minSd, aes(x=scenID)) + geom_histogram(binwidth=.5, colour="black", fill="white")


# Plot (pixels with highest yield in each category of sowing date and hybrid)
grid.arrange(hg1, hg2,hg3, ncol=3)
```

# How is total biomass and inter-annual variability related?

> In general **highest** yields have **lowest variability**

```{r BioVsCv, echo=FALSE}

workDF_med$Bio_meanTons <- workDF_med$Bio_mean / 1000 # convert kg/ha to t/ha

#different panels by hybrid
workDF_med %>%
ggplot(aes(x= Bio_meanTons , y=Bio_cv)) +  
geom_point(aes(colour = factor(thisRegion )) ) +
facet_grid(thisSow ~thisHyb, scales="free")

```

# Rasterise for mapping

> Checking data-frame

> Plot statistics for n Years 

## Pixels with highest Total Silage Biomass

> Maps show stats and which hybrid and sowing date was selected in each pixel

```{r MapsHighYield, echo=FALSE, warning=FALSE, include = FALSE}

df_maxY <- df_maxY %>% filter(thisHyb != "h2"| thisHyb != "h4"| thisSow != "s1"| thisSow != "s5")

mapDf <- workDF %>% 
  select(pixel_ID, thisLat, thisLong, TotalBiomass) %>%
  group_by(pixel_ID)  %>% 
  summarise(Bio_mean = mean(TotalBiomass, na.rm = TRUE), Bio_sd = sd(TotalBiomass, na.rm = TRUE))  %>% 
  mutate(Bio_cv = (Bio_sd/Bio_mean*100)) - # FIXME: not finished

par(mfrow = c(1,1))
outNames <- colnames(mapDf) # Using maximum grain yield

outNames <- gsub(" ","",outNames )

# ignore first 6 factors
spg <- list() # dataframe list to be coerced as spatial object
rast <- list() # raster
s <- list()

for(o in 2:length(outNames)){
if (o == 12) {next} # other label to ignore (FIXME: Still selected by hand)

  # For each variable aggregation
  spg[[o]] <- data.frame(mapDf$thisLong, mapDf$thisLat, mapDf[[o]])
  coordinates(spg[[o]]) <- ~ mapDf.thisLong + mapDf.thisLat # Attention to variable names
 
  # Common to both methods (grid, raterise and project)
  gridded(spg[[o]]) <- TRUE
  rast[[o]] <- raster(spg[[o]])
  proj4string(rast[[o]]) <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"

 plot(rast[[o]], main = paste0("Var: ", outNames[o]))

  # stack them
  if(o == 1) {
    s <- stack(rast[[o]])} # create stack
  else {
    s[[o]] <- rast[[o]]
  }
  
  # save raster as
  writeRaster(rast[[o]], file=paste0(outNames[o],"_var",".tiff"), overwrite=TRUE) 
}

```

Test yield over time

```{r YieldChangeTime}

# Is yield potential changing in past 30 years?
# FIXME: not working now
slopesDF <- NULL
slopesDF <- workDF %>%
 select (pixel_ID, thisSow, thisHyb, thisLat, thisLong, TotalBiomass, year) %>%
 group_by(pixel_ID, thisSow, thisHyb) %>%
# filter(TotalBiomass > 100) %>%
 do(mod = lm(TotalBiomass ~ year, data = .)) %>%
  mutate(Slope = coef(mod)[2], 
         Intercept = coef(mod)[1], 
         Pval = coef(mod)[8]) %>%
  filter (Pval <= 0.05) %>% # select pixels with significant slope
  select(-mod)
  head(slopesDF)

# Try data table
library(data.table)
setDT(workDF)[, list(Slope = summary(lm(TotalBiomass ~ year))$coeff[2]),  pixel_ID] # how to agregate by many

  #FIXME: this merge is multiplying unecesary pixels
  slopesDF <- workDF %>%
 # select(pixel_ID, thisSow, thisHyb, TotalBiomass, thisLat, thisLong) %>%
  group_by(pixel_ID, thisSow, thisHyb) %>%
  summarise_each(funs(mean)) %>%
  merge(slopesDF, by = c("pixel_ID", "thisSow", "thisHyb"))

# slopesDF <- merge(slopesDF, xx, by = c("pixel_ID", "thisSow", "thisHyb"))

```


```{r SlopeAnalysis}
slopesDF %>%
  select(thisSow, thisHyb, slope) %>%
  ggplot(aes(x=thisSow, y=slope)) +
  geom_boxplot() +
  geom_jitter(aes(colour = thisHyb))


slopesDF %>%
  select(thisLat, thisSow, thisHyb, slope) %>%
  ggplot(aes(x=thisLat, y=slope)) +
  geom_point(aes(colour = thisHyb)) +
  facet_grid(thisSow~.)

head(slopesDF)

# Test some pixels
workDF %>%
filter(pixel_ID == "149_131" & TotalBiomass > 100) %>%
select(year, TotalBiomass, thisSow, thisHyb) %>%
ggplot(aes(x= year , y=TotalBiomass)) +  
geom_smooth(method=lm) +  
geom_point() +
facet_grid(thisHyb ~ thisSow)


```

Map slope

```{r MapYieldSlope}

# map the pixels with change 

spg <- list() # dataframe list to be coerced as spatial object
rast <- list() # raster
s <- list()
sow <- c("s1", "s2", "s3", "s4", "s5")
hyb <- c("h1", "h2", "h3", "h4", "h5")
count <- 0
par(mfrow=c(1,2))
for(s in 1:length(sow)) {
  for(h in 1:length(hyb))  {
  count <- count + 1  
  
  mapDF <- slopesDF %>%
  subset(thisSow == sow[s] & thisHyb == hyb[h])
    
  # For aggregate
  spg[[count]] <- data.frame(mapDF$thisLong, mapDF$thisLat, mapDF$slope)
  coordinates(spg[[count]]) <- ~ mapDF.thisLong + mapDF.thisLat # Attention to variable names
  
  # Common to both methods (grid, raterise and project)
  gridded(spg[[count]]) <- TRUE
  rast[[count]] <- raster(spg[[count]])
  proj4string(rast[[count]]) <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"
  
  plot(rast[[count]], main = paste0(sow[s]," ",hyb[h]))
  writeRaster(rast[[count]], file=paste0("Slope_", paste0(sow[s],"_",hyb[h],".tiff")), overwrite=TRUE) 
 
  
    }
  }
```
