---
title: "AnalyseGEM"
author: "edmar.teixeira@me.com"
date: "Sunday, December 07, 2014"
output: html_document
---

# Background

## Aim

Quantify **uncertanty** (sensitivity of model to?) coming from the choice of (possible?) **sowing dates and maize hybrids** in regional simulations

## Method

> Use APSIM 7.4

> Run model for ~2700 pixels of 5 x 5 km (NIWA ref XXX) across New Zealand

> Arable land filter frpm LandCare (ref XXX)

> Run 30 years (XXX-XXXX) of data from NIWA (XXXX)

> Run 5 hybrid maturity types (parameter XXXX with values x, x, x, x, x)

> Run at 5 different sowng dates (1-Sep, 1-Oct, 1-Nov, 1-Dec, 1-Jan)


# Data Manipulation

```{r LoadLibs, echo=TRUE, include=FALSE}
library(ggplot2)
library(dplyr)
library(plot3D)
library(gridExtra)
library(tidyr)
library(raster)
library(mapproj)
```

## Retrieve data and check
```{r GetData, include=FALSE}
# load data from HD
#setwd("E:\\SowByGenotype")
setwd("C:\\Apsim_dev\\Projects\\2014-SowByGenotype\\GEM_data")

load("DATA_GEM.Rda", .GlobalEnv)


head(DATA_GEM)
tail(DATA_GEM)
summary(DATA_GEM)
```

> Subset to keep only maize (exclude winter forage wheat) and order factors

```{r TidyUp, echo = FALSE, include=FALSE}
# Remove wheat (catch crop rotation) and keep only maize data

workDF <- subset(DATA_GEM, CurrentCrop != 'wheat_exceed')

# order sow dates
workDF$thisSow = factor(workDF$thisSow, levels = c('s1', 's2', 's3', 's4', 's5'))

#creates ID for each pixel
workDF$pixel_ID <- paste0(workDF$row,"_",workDF$col)

# Creates a year field as factor
workDF$yearAsFact <- as.factor(paste0(workDF$year,"_Y"))

summary(workDF)

```



```{r AddRegionCode, echo = FALSE, include = FALSE}

# Read region data
df_region <- as.data.frame(read.csv(file = 
                                        paste0("C:\\Apsim_dev\\Projects\\2014-SowByGenotype\\GEM_data\\",
                                   "RegionPerPixel.csv") ))
head(df_region)

df_region <- df_region %>%
  select(row, col, region)


workDF <- merge(workDF, df_region, by = c("col", "row"))

summary(workDF)

```



## Graph some results

> Total silage biomass by sowing date (kg/ha)

```{r GraphBySow, echo=FALSE}

# Pooled pixels response to sow date by hybrid

# Total biomass
workDF %>%
#subset(region == 4 |region == 11 | region == 13) %>%
ggplot(aes(x= thisSow , y=TotalBiomass)) +  
geom_boxplot() +
#facet_grid(region ~ thisHyb)
facet_grid(.~ thisHyb)

# Total Yield
workDF %>%
#subset(region == 4 |region == 11 | region == 13) %>%
ggplot(aes(x= thisSow , y=TotalYield)) +  
geom_boxplot() +
#facet_grid(region ~ thisHyb)
facet_grid(.~ thisHyb)

# Harvest Index
workDF %>%
ggplot(aes(x= thisSow , y=HarvestIndex)) +  
geom_boxplot() +
facet_grid( .~ thisHyb)

# Water Use
workDF %>%
ggplot(aes(x= thisSow , y=ETact)) +  
geom_boxplot() +
facet_grid( .~ thisHyb)

# Water Use Efficiency
workDF %>%
ggplot(aes(x= thisSow , y=WUE)) +  
geom_boxplot() +
facet_grid( .~ thisHyb)

# Water Use Efficiency
workDF %>%
ggplot(aes(x= thisSow , y=WUE)) +  
geom_boxplot() +
facet_grid( .~ thisHyb)

```

> Total silage biomass by hybrid type (kg/ha)

This form of display seems more interesting.

- Advantege of long hybrids is reduced at late sowing dates

```{r GraphByHyb, echo = FALSE}

# Pooled response to Hybrid (Bio)
# Total biomass
workDF %>%
#subset(region == 4 |region == 11 | region == 13) %>%
ggplot(aes(x= thisHyb , y=TotalBiomass)) +  
geom_boxplot() +
#facet_grid( region~ thisSow)
facet_grid(.~ thisSow)

# Total Yield
workDF %>%
ggplot(aes(x= thisHyb , y=TotalYield)) +  
geom_boxplot() +
facet_grid( .~ thisSow)

# Harvest Index
workDF %>%
ggplot(aes(x= thisHyb , y=HarvestIndex)) +  
geom_boxplot() +
facet_grid( .~ thisSow)

# Water Use
workDF %>%
ggplot(aes(x= thisHyb , y=ETact)) +  
geom_boxplot() +
facet_grid( .~ thisSow)

# Water Use Efficiency
workDF %>%
ggplot(aes(x= thisHyb , y=WUE)) +  
geom_boxplot() +
facet_grid( .~ thisSow)

# Water Use Efficiency
workDF %>%
ggplot(aes(x= thisHyb , y=WUE)) +  
geom_boxplot() +
facet_grid( .~ thisSow)

```

# Analysis

## Calculate variability as CV%

> Just to have an initial idea of variability

> Considers variation among YEARS and PIXELS together

> Pooled among hybrids and sowing dates


```{r GraphCVs, echo =FALSE}
# polled CV across hybrids and sowing dates
workDF %>%
  group_by(thisSow, thisHyb) %>%
  summarise(CVperc = sd(TotalBiomass, na.rm = TRUE)/mean(TotalBiomass, na.rm = TRUE)*100) %>%
  ggplot(aes(x= thisHyb , y=CVperc)) +  
  geom_point() +
  facet_grid( .~ thisSow)

workDF %>%
  group_by(thisSow, thisHyb) %>%
  summarise(CVperc = sd(TotalBiomass, na.rm = TRUE)/mean(TotalBiomass, na.rm = TRUE)*100) %>%
  ggplot(aes(x= thisSow , y=CVperc)) +  
  geom_point() +
  facet_grid( .~ thisHyb)


workDF %>%
  group_by(thisSow, thisHyb) %>%
  summarise(CVperc = sd(TotalBiomass, na.rm = TRUE)/mean(TotalBiomass, na.rm = TRUE)*100) %>%
  ggplot(aes(x= thisSow , y=CVperc, fill=thisSow)) +  
  geom_bar(stat='identity') +
  facet_grid( .~ thisHyb)


workDF %>%
  group_by(thisSow, thisHyb) %>%
  summarise(CVperc = sd(TotalBiomass, na.rm = TRUE)/mean(TotalBiomass, na.rm = TRUE)*100) %>%
  ggplot(aes(x= thisHyb , y=CVperc, fill=thisHyb)) +  
  geom_bar(stat='identity') +
  facet_grid( .~ thisSow)

```

## Values pooled (median, mean, stdev) across **years** 

> Statistics of n years per pixel/scenario of hybrid and sow date combination

> Also creates a ID for each pixel-h-s combination (FIXME: maybe redundant now)

```{r CreateMedCV_df, echo = FALSE}
# Create a median and stdev for each pixel-h-s, polled across YEARS (i.e. year is not included in grouping)

workDF_med <- workDF %>%
  group_by(row,col,pixel_ID, thisHyb,thisSow) %>%
  summarise( thisLat = mean(thisLat, na.rm = TRUE),
             thisLong = mean(thisLong, na.rm = TRUE),
             Bio_mean = mean(TotalBiomass, na.rm = TRUE),
             Bio_med = median(TotalBiomass, na.rm = TRUE),
             Bio_sdv = sd(TotalBiomass, na.rm = TRUE),
             Bio_cv = (Bio_sdv/Bio_mean)*100,
             Y_mean = mean(TotalYield, na.rm = TRUE),
             Y_med = median(TotalYield, na.rm = TRUE),
             Y_sdv = sd(TotalYield, na.rm = TRUE),
             Y_cv = (Y_sdv/Y_mean)*100,
             HI_med = median(HarvestIndex, na.rm = TRUE)) %>%
             mutate(scenID = paste0(thisHyb,"_",thisSow)) %>%
             mutate(pixel_scenID=paste0(row,"_",col,"_",thisHyb,"_",thisSow))  

# make hybrid and sow date as numbers (for using in raster later) 
# FIXME: do this in a prettier way later
workDF_med$thisSow_n[workDF_med$thisSow == "s1"] <- 1
workDF_med$thisSow_n[workDF_med$thisSow == "s2"] <- 2
workDF_med$thisSow_n[workDF_med$thisSow == "s3"] <- 3
workDF_med$thisSow_n[workDF_med$thisSow == "s4"] <- 4
workDF_med$thisSow_n[workDF_med$thisSow == "s5"] <- 5

workDF_med$thisHyb_n[workDF_med$thisHyb == "h1"] <- 1
workDF_med$thisHyb_n[workDF_med$thisHyb == "h2"] <- 2
workDF_med$thisHyb_n[workDF_med$thisHyb == "h3"] <- 3
workDF_med$thisHyb_n[workDF_med$thisHyb == "h4"] <- 4
workDF_med$thisHyb_n[workDF_med$thisHyb == "h5"] <- 5

head(workDF_med)
tail(workDF_med)

```

Select some pixels across the range of results

```{r 3DGraphsByPixel, echo = FALSE}

# Give me the 25th percentile of Biomass
df_p <- workDF_med %>% 
  group_by(row, col) %>%
  mutate(perc = rank(Bio_med)/length(Bio_med))

head(df_p)
summary(df_p$perc)

# select 3 "sample" pixels to graph

df_sel <- data.frame(rowsSel = c(67, 184, 239), colsSel = c(180, 113, 38) )

# loop each selected pixel and graph
for (p in 1:nrow(df_sel)) {
  
df_pix <- df_p %>% group_by(row, col) %>%
  filter(row==df_sel$rowsSel[p] & col==df_sel$colsSel[p])

#head(df_pix, 25)
# save pixel data
write.table(df_pix, file=paste0(df_sel$rowsSel[p],"_",df_sel$colsSel[p],"_","3D_graph.txt"), row.names=FALSE, col.names=TRUE, sep=" ",
               append=FALSE, quote=FALSE)

# graph it
par(mfrow = c(1, 2))

# Plot 3 D graph
z <- matrix(df_pix$Bio_med,                       # the data elements 
nrow=length(unique(df_pix$thisHyb)),              # number of rows 
ncol=length(unique(df_pix$thisSow)),              # number of columns 
byrow = TRUE)                                     # fill matrix by rows 
colnames(z) = unique(df_pix$thisHyb_n)
rownames(z) = unique(df_pix$thisSow_n)

x = as.numeric(colnames(z))
y = as.numeric(rownames(z))
  
persp3D(x, y, z, theta=60, phi=10, expand=0.75,
        main= paste0("Bio_mean: ",df_sel$rowsSel[p],"_",df_sel$colsSel[p]),
        ticktype="detailed", lighting = TRUE, 
        xlab="Sow date", ylab="Hybrid", zlab="Biomass (t/ha)",axes=TRUE)


# variaility
# PLot 3 D graph
z = matrix(df_pix$Bio_sd, # the data elements 
nrow=length(unique(df_pix$thisHyb)),              # number of rows 
ncol=length(unique(df_pix$thisSow)),              # number of columns 
byrow = TRUE)        # fill matrix by rows 
colnames(z) = unique(df_pix$thisHyb_n)
rownames(z) = unique(df_pix$thisSow_n)

x = as.numeric(colnames(z))
y = as.numeric(rownames(z))
  
persp3D(x, y, z, theta=60, phi=10, expand=0.75, 
        main= paste0("Bio_CV: ",df_sel$rowsSel[p],"_",df_sel$colsSel[p]),
        ticktype="detailed", lighting = TRUE, xlab="Sow date", 
        ylab="Hybrid", zlab="Biomass (t/ha)",axes=TRUE)

}

```

## Find hybrid x sow date with **highest yield** in each pixel

> This is to check the data "sensibility"

> FIXME: Check this dplyr script and logic as it seems that almost  **NO variation** is coming from this 

> Most productive sowing dates are **S1 (Sept) and S2 (Oct) **

> Most productive is always **hybrid 5** (longest hybrid)


```{r FindHighBio, echo=FALSE}
# select line with maximum biomass per pixel
df_maxBio <- workDF_med %>% 
  group_by(row, col) %>%
 # mutate(coord_code = paste0(thisHyb,"_",thisSow)) %>%
  filter(Bio_med == max(Bio_med))

# highest yield
df_maxY <- workDF_med %>% 
  group_by(row, col) %>%
#  mutate(coord_code = paste0(thisHyb,"_",thisSow)) %>%
   filter(Y_med == max(Y_med))

# lowest CV
df_minSd <- workDF_med %>% 
 group_by(row, col) %>%
#mutate(coord_code = paste0(thisHyb,"_",thisSow)) %>%
 filter(Bio_cv == min(Bio_cv))



#PLot histograms
hg1 <- ggplot(df_maxBio, aes(x=scenID)) + geom_histogram(binwidth=.5, colour="black", fill="white")
hg2 <- ggplot(df_maxY, aes(x=scenID)) + geom_histogram(binwidth=.5, colour="black", fill="white")
hg3 <- ggplot(df_minSd, aes(x=scenID)) + geom_histogram(binwidth=.5, colour="black", fill="white")


# Plot (pixels with highest yield in each category of sowing date and hybrid)
grid.arrange(hg1, hg2,hg3, ncol=3)
```

# How is total biomass and inter-annual variability related?

> In general **highest** yields have **lowest variability**

```{r BioVsCv, echo=FALSE}

workDF_med$Bio_meanTons <- workDF_med$Bio_mean / 1000 # convert kg/ha to t/ha

#different panels by hybrid
workDF_med %>%
ggplot(aes(x= Bio_meanTons , y=Bio_cv)) +  
geom_point(aes(colour = factor(regions )) ) +
facet_grid(thisSow ~thisHyb, scales="free")

```

# Rasterise for mapping

> Checking data-frame

> Plot statistics for n Years 

## Pixels with highest Total Silage Biomass

> Maps show stats and which hybrid and sowing date was selected in each pixel

```{r MapsHighYield, echo=FALSE, warning=FALSE, include = FALSE}

par(mfrow = c(1,1))
outNames <- colnames(df_maxY) # Using maximum grain yield

outNames <- gsub(" ","",outNames )

# ignore first 6 factors
spg <- list() # dataframe list to be coerced as spatial object
rast <- list() # raster
s <- list()

for(o in 7:length(outNames)){
if (o == 12) {next} # other label to ignore (FIXME: Still selected by hand)

  # For each variable aggregation
  spg[[o]] <- data.frame(df_maxY$thisLong, df_maxY$thisLat, df_maxY[[o]])
  coordinates(spg[[o]]) <- ~ df_maxY.thisLong + df_maxY.thisLat # Attention to variable names
 
  # Common to both methods (grid, raterise and project)
  gridded(spg[[o]]) <- TRUE
  rast[[o]] <- raster(spg[[o]])
  proj4string(rast[[o]]) <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"

 plot(rast[[o]], main = paste0("Var: ", outNames[o]))

  # stack them
  if(o == 1) {
    s <- stack(rast[[o]])} # create stack
  else {
    s[[o]] <- rast[[o]]
  }
  
  # save raster as
  #writeRaster(rast[[o]], file=paste0(cropNames[c],"\\",thisCrop,"_", outNames[o],"_var",".tiff"), overwrite=TRUE) 
}

```


## Show maps when selecting run with **lowest variability**


```{r MapsLowCv, echo=FALSE, warning=FALSE}
par(mfrow=c(1,1))
outNames = colnames(df_minSd)
outNames =gsub(" ","",outNames )

# ignore first 6 factors
spg = list() # dataframe list to be coerced as spatial object
rast = list() # raster
s=list()
for(o in 7:length(outNames)){
if (o == 12) {next} # other label to ignore

  # For aggregate
  spg[[o]] = data.frame(df_minSd$thisLong, df_minSd$thisLat, df_minSd[[o]])
  coordinates(spg[[o]]) = ~ df_minSd.thisLong + df_minSd.thisLat # Attention to variable names
 
  # Common to both methods (grid, raterise and project)
  gridded(spg[[o]]) <- TRUE
  rast[[o]] = raster(spg[[o]])
  proj4string(rast[[o]]) = "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"

 plot(rast[[o]], main = paste0(outNames[o]))

  # stack them
  if(o == 1) {
    s = stack(rast[[o]])} 
  else {
    s[[o]] = rast[[o]]
  }
  
  # save raster as
  #writeRaster(rast[[o]], file=paste0(cropNames[c],"\\",thisCrop,"_", outNames[o],"_var",".tiff"), overwrite=TRUE) 
}

```


## Calculate the relative variability for factors

> How much of overall variation is coming from sowing date, hybrid and their interaction?

> Adapting Esther Meenken method of sensitivity analysis for that

> Run a ANOVA and retrive the Sums of Squares (SS) of each factor (3 main factors and the interaction)

> Display it as a relative proportion of total variation (% of total SS)

> This is the **Si index** summary:

```{r ANOVA, echo =FALSE}
# do an anova for each pixel 
si_df_final <- NULL
pixels <- unique(workDF_med$pixel_ID)

summary(workDF) # Should I use workDF?

# for (p in 1:4) { # for script test
 for (p in 1:length(pixels)) {

  
  # thisPixDF <- filter(workDF_med, pixel_ID == pixels[[p]])
  thisPixDF <- filter(workDF, pixel_ID == pixels[[p]])
  
  head(thisPixDF)
  summary(thisPixDF)
         
  # do anova
  anova <- aov(TotalBiomass ~ thisHyb*thisSow*yearAsFact, data = thisPixDF)

  anovaTable <- summary(anova)
  
  #Retrive SS and MS values
  anova_SS <- anovaTable[[1]]$'Sum Sq'
  anova_MS <- anovaTable[[1]]$'Mean Sq' 

  # Binds all SS for each variable together into a new df
  df_ss <- data.frame(SS = anova_SS, MS = anova_MS)

  #retrieves row names and load into result df
  namesAnTab <- rownames(anovaTable[[1]])
  rownames (df_ss) <- gsub(" ","",namesAnTab) # remove spaces
 
 # get names and count of main factors
 mainFact <- rownames (df_ss)[-grep(':',rownames (df_ss))] # isolate the main factors from

  # Creates a column with "normalised" percent of total variation (SS) 
  # in relation to total SS for each factor in that pixel
  df_ss$SS_p <- round((df_ss$SS/sum(df_ss$SS))*100,3)
  df_ss$MS_p <- round((df_ss$MS/sum(df_ss$MS))*100,3) 
  # FIXME: Not sure which to use SS or MS - Esther Menkeen suggested SS
 
  df_si <- data.frame(thisLat = thisPixDF$thisLat[1],
                   thisLong = thisPixDF$thisLong[1],
                   thisRegion = thisPixDF$region[1],
                   df_ss$SS_p[1], 
                   df_ss$SS_p[2], 
                   df_ss$SS_p[3],
                   df_ss$SS_p[4]
                   )
  
 # isolate factor labels from data
 factNames <- colnames (df_si)[-grep('ss',colnames (df_si))] # isolate the main factors from anova
 noFactors <- length(factNames)  # counts row names that do not have ":" i.e. from interaction
 
  # label Si df FIXME: Automate this
  colnames(df_si)[noFactors+1] <- gsub(" ","",paste0("Si_",mainFact[1]))
  colnames(df_si)[noFactors+2] <- gsub(" ","",paste0("Si_",mainFact[2]))
  colnames(df_si)[noFactors+3] <- gsub(" ","",paste0("Si_",mainFact[3]))
  colnames(df_si)[noFactors+4] <- "Si_Interac"
  
  # Appends to final Si df
  if(p==1){ 
    si_df_final <- data.frame(df_si)  
    } else {
    si_df_final <- rbind(si_df_final, df_si)
    }
  
}

summary(si_df_final)
nrow(si_df_final)
gH <- ggplot(si_df_final, aes(x=Si_thisHyb)) + geom_histogram(binwidth=.5, colour="black", fill="white")
gS <- ggplot(si_df_final, aes(x=Si_thisSow)) + geom_histogram(binwidth=.5, colour="black", fill="white")
gW <- ggplot(si_df_final, aes(x=Si_yearAsFact)) + geom_histogram(binwidth=.5, colour="black", fill="white")
gI <- ggplot(si_df_final, aes(x=Si_Interac)) + geom_histogram(binwidth=.5, colour="black", fill="white")

# All plotted together (TODO: Do it by region)
fontSize <- 14
si_df_final %>%
  subset(thisRegion == 6:8) %>%
  group_by(thisLat, thisLong) %>%
  gather(factName, siVal, 3:6) %>%
  ggplot(aes(x= siVal, colour=factName, fill=factName)) + 
  geom_histogram(aes(y=..density..), binwidth=.8, alpha=0) +
  geom_density(alpha=0.2,size=1.5) +
  xlab("Percent of total variability (%)") +
  ylab("Frequency distribution") +
  theme(text = element_text(size=fontSize)) +
  theme(legend.position = c(0, 1), 
       legend.justification = c(-3, 1)) 

# Plot distributions of Si
#grid.arrange(gH, gS, gW,gI, nrow=4)
```

> Histograms show frequency of pixels in each range of Si for each factor and interactions

## Map Si index

> Si is the fraction of total sums of squares attributed to each main factor or interactions

> Let's plot it: 

```{r MapSi, echo = FALSE, warning=FALSE}
outNames <- colnames(si_df_final)
outNames <- gsub(" ","",outNames )
par(mfrow=c(1,(length(mainFact)+1)))

# ignore first 6 factors
spg <- list() # dataframe list to be coerced as spatial object
rast <- list() # raster
s <- list()

# TODO: add a region code and then plot it for each region in the loop
for(o in length(mainFact):length(outNames)){

  # For aggregate
  spg[[o]] = data.frame(si_df_final$thisLong, si_df_final$thisLat, si_df_final[[o]])
  coordinates(spg[[o]]) = ~ si_df_final.thisLong + si_df_final.thisLat # Attention to variable names
 
  # Common to both methods (grid, raterise and project)
  gridded(spg[[o]]) <- TRUE
  rast[[o]] <- raster(spg[[o]])
  proj4string(rast[[o]]) <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"

  # stack them
  if(o == 1) {
    s <- NULL
    s <- stack(rast[[o]])} 
  else {
    s[[o]] <- rast[[o]]
  }
  
  # save raster as
  writeRaster(rast[[o]], file=paste0("Si_", outNames[o],".tiff"), overwrite=TRUE) 
  
  # plot them
  factNames <- c("xx","xx", "Hybrid","Sow date", "Weather", "Interactions")
   plot(rast[[o]], main = paste0(factNames[o]))
  # map('nz')
}
#map(database= "usa", col="#FFFFFF", fill=FALSE,add=TRUE, lwd=1.5)

```




